<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HTML Q‑Sort — 9점 강제분포 (−4…+4)</title>
  <style>
    :root{
      --bg:#0f172a; /* slate-900 */
      --panel:#111827; /* gray-900 */
      --card:#1f2937; /* gray-800 */
      --muted:#94a3b8; /* slate-400 */
      --text:#e5e7eb; /* gray-200 */
      --accent:#6366f1; /* indigo-500 */
      --ok:#22c55e; /* green-500 */
      --warn:#f59e0b; /* amber-500 */
      --bad:#ef4444; /* red-500 */
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font:16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Apple SD Gothic Neo, Noto Sans KR, sans-serif}
    header{position:sticky;top:0;z-index:50;background:linear-gradient(180deg, rgba(15,23,42,.95), rgba(15,23,42,.6));backdrop-filter:blur(8px);border-bottom:1px solid #1f2937}
    .wrap{max-width:1200px;margin:0 auto;padding:16px}
    h1{font-size:20px;margin:0 0 6px}
    .sub{color:var(--muted);font-size:13px}
    .grid{display:grid;grid-template-columns:320px 1fr;gap:16px;margin-top:12px}
    #pool, .col{background:var(--panel);border:1px solid #2b3647;border-radius:12px}
    #pool{padding:12px;min-height:220px}
    .toolbar{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0}
    button, select, input[type=file]{background:var(--card);color:var(--text);border:1px solid #334155;border-radius:10px;padding:8px 10px;font-weight:600}
    button:hover{border-color:var(--accent)}
    .note{font-size:13px;color:var(--muted)}
    .cols{display:grid;gap:10px}
    .row{display:grid;gap:10px;grid-template-columns:repeat(9,1fr)}
    .col{min-height:120px;padding:8px;display:flex;flex-direction:column}
    .col-header{display:flex;align-items:center;justify-content:space-between;padding:4px 6px;margin-bottom:6px;border-bottom:1px dashed #334155}
    .tag{font-size:12px;color:var(--muted)}
    .cap{font-size:12px}
    .bucket{display:flex;flex-direction:column;gap:6px}
    .card{background:var(--card);border:1px solid #334155;border-radius:12px;padding:10px;cursor:grab}
    .card.dragging{opacity:.6}
    .col.over{outline:2px dashed var(--accent);outline-offset:-4px}
    .count-ok{color:var(--ok)}
    .count-warn{color:var(--warn)}
    .count-bad{color:var(--bad)}
    .small{font-size:12px}
    footer{border-top:1px solid #1f2937;margin-top:16px}
    .chips{display:flex;gap:6px;flex-wrap:wrap;margin-top:6px}
    .chip{background:#0b1222;border:1px solid #2b3647;border-radius:999px;padding:2px 8px;font-size:12px}
    .hidden{display:none}
    textarea{width:100%;min-height:140px}
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <h1>HTML Q‑Sort — 9점 강제분포 (−4 … +4)</h1>
      <div class="sub">드래그 앤 드롭으로 카드를 배치하세요. 배치 용량을 넘기면 칸 테두리가 빨갛게 표시됩니다. 좌측 상단에서 분포 프리셋, 가져오기/내보내기를 사용할 수 있습니다.</div>
    </div>
  </header>
  <main class="wrap">
    <section class="grid">
      <aside>
        <h2 style="margin:8px 0 6px;font-size:16px">카드 풀(미배치)</h2>
        <div id="pool" class="dropzone" data-score="pool">
          <div class="note">여기에 놓으면 카드가 ‘미배치’ 상태가 됩니다.</div>
          <div id="poolList" class="bucket"></div>
        </div>

        <div class="toolbar">
          <select id="preset">
            <option value="40-9">분포 프리셋: 40문항 · 9점 (2,3,5,6,8,6,5,3,2)</option>
            <option value="39-9">분포 프리셋: 39문항 · 9점 (2,3,4,6,9,6,4,3,2)</option>
            <option value="36-9">분포 프리셋: 36문항 · 9점 (2,4,6,8,8,8,6,4,2)</option>
          </select>
          <button id="reset">분포 초기화</button>
        </div>

        <div class="toolbar">
          <input type="file" id="importFile" accept=".csv,.txt,.json" />
          <button id="exportCSV">CSV 내보내기</button>
          <button id="exportJSON">JSON 내보내기</button>
        </div>
        <div class="note">가져오기 규칙: <span class="chip">CSV: 번호,코드,진술문</span> · <span class="chip">JSON: {id,code,text}</span></div>

        <details style="margin-top:10px">
          <summary>현재 배치 요약</summary>
          <div id="summary" class="small" style="margin-top:6px"></div>
        </details>
      </aside>

      <section>
        <div class="cols">
          <div class="row" id="row">
            <!-- 9 columns inserted by JS -->
          </div>
        </div>
        <div class="chips" id="legend"></div>
      </section>
    </section>

    <footer class="wrap" style="padding:8px 0 24px">
      <div class="small">© HTML Q‑Sort demo. 드래그가 어려운 환경에서는 카드 클릭 → 목적 칸 클릭으로도 이동됩니다.</div>
    </footer>
  </main>

  <script>
    // ====== 설정 ======
    const PRESETS = {
      '40-9': { scores:[-4,-3,-2,-1,0,1,2,3,4], caps:[2,3,5,6,8,6,5,3,2] },
      '39-9': { scores:[-4,-3,-2,-1,0,1,2,3,4], caps:[2,3,4,6,9,6,4,3,2] },
      '36-9': { scores:[-4,-3,-2,-1,0,1,2,3,4], caps:[2,4,6,8,8,8,6,4,2] }
    };

    // 데모용 기본 카드(필요시 교체). 한국어 텍스트 예시.
    const DEFAULT_STATEMENTS = [
      // 유목 1-12
      {id:1, code:'유목', text:'지리 수업에서는 국가 수준의 성취기준보다 학생과 지역의 특수성을 먼저 고려해야 할 때가 있다.'},
      {id:2, code:'유목', text:'문서에 적힌 목표는 교과서 예시에만 머무르지 않고, 학생의 생활과 연결해 가르칠 수 있다.'},
      {id:3, code:'유목', text:'교사는 문서에 나온 순서를 그대로 따르기보다 상황에 맞게 바꿔 수업을 만들 수 있다.'},
      {id:4, code:'유목', text:'정해진 기준이 있어도 교사의 자율적 선택은 정당하다.'},
      {id:5, code:'유목', text:'지리 수업의 의미는 교사·학생·교실·지역 자료가 어떻게 어울리느냐에 따라 달라진다.'},
      {id:6, code:'유목', text:'학생의 경험을 반영하여 목표를 변형해도 교육적 가치가 있다.'},
      {id:7, code:'유목', text:'교과서 바깥의 지역 자료도 충분히 수업의 핵심이 될 수 있다.'},
      {id:8, code:'유목', text:'국가 지침은 통제이면서도 해석의 가능성을 남긴다.'},
      {id:9, code:'유목', text:'한 가지 방식이 아니라 여러 갈래의 길을 허용하는 수업이 필요하다.'},
      {id:10, code:'유목', text:'교사의 현장 재구성이 수업의 질을 높인다.'},
      {id:11, code:'유목', text:'학생과 지역의 특수성이 기준보다 우선될 수 있다.'},
      {id:12, code:'유목', text:'문서에 없는 주제라도 학생 삶과 연결되면 다룰 수 있다.'},
      // 시뮬라시옹 13-24
      {id:13, code:'시뮬라시옹', text:'목표와 개념은 현실의 지리 현상과 연결되기보다 문서 속 정해진 표현으로 반복되는 경우가 많다.'},
      {id:14, code:'시뮬라시옹', text:'수업은 학생의 실제 경험보다 평가 기준에 맞추어 진행되기 쉽다.'},
      {id:15, code:'시뮬라시옹', text:'복잡한 현실은 단순한 모형으로 제시되곤 한다.'},
      {id:16, code:'시뮬라시옹', text:'학생 참여는 자율적 탐구보다 형식적 수행으로 흐를 수 있다.'},
      {id:17, code:'시뮬라시옹', text:'교사의 해석은 현실보다는 문서와 지표에 더 충실해진다.'},
      {id:18, code:'시뮬라시옹', text:'지리적 쟁점은 도식과 예시에 갇히기 쉽다.'},
      {id:19, code:'시뮬라시옹', text:'세계 시민, 지속가능성 같은 용어가 실제 문제와 동떨어져 반복된다.'},
      {id:20, code:'시뮬라시옹', text:'디지털 지도보다 정해진 도표 읽기에 치우칠 때가 있다.'},
      {id:21, code:'시뮬라시옹', text:'학생은 현실의 다양성보다 정형화된 틀로 배우기 쉽다.'},
      {id:22, code:'시뮬라시옹', text:'평가 체계 요구를 벗어나기 어렵다.'},
      {id:23, code:'시뮬라시옹', text:'모범 답안 찾기가 탐구보다 우선될 때가 있다.'},
      {id:24, code:'시뮬라시옹', text:'문서 반복 용어가 수업의 실제와 멀어질 때가 있다.'},
      // 실존 25-40 (여기선 16개 넣어 총 40개 예시)
      {id:25, code:'실존', text:'지리 수업은 교사 자신을 되돌아보게 한다.'},
      {id:26, code:'실존', text:'학생은 지리를 통해 자기 삶을 돌아볼 수 있어야 한다.'},
      {id:27, code:'실존', text:'사실의 나열보다 삶의 의미를 묻는 수업이 필요하다.'},
      {id:28, code:'실존', text:'해석이 학생의 생활세계와 연결될 때 의미가 있다.'},
      {id:29, code:'실존', text:'교사와 학생이 함께 성찰하는 장이 되어야 한다.'},
      {id:30, code:'실존', text:'목표는 학생 가능성을 발견하는 기회가 되어야 한다.'},
      {id:31, code:'실존', text:'지식 전달을 넘어 삶의 문제와 연결되어야 한다.'},
      {id:32, code:'실존', text:'학생이 자기 삶과 세계를 질문할 수 있어야 한다.'},
      {id:33, code:'실존', text:'경험 속에서 의미를 발견하는 수업을 중시한다.'},
      {id:34, code:'실존', text:'학생이 주체적으로 살아가도록 돕는다.'},
      {id:35, code:'실존', text:'문서를 읽는 일은 교사에게도 성찰의 기회가 된다.'},
      {id:36, code:'실존', text:'우리는 함께 세계 속에서 살아감을 드러내야 한다.'},
      {id:37, code:'유목', text:'문서의 큰 흐름만 참고하고 현장에 맞게 재구성할 수 있다.'},
      {id:38, code:'시뮬라시옹', text:'도시 모형 같은 틀은 현실의 다양성을 과소화할 수 있다.'},
      {id:39, code:'시뮬라시옹', text:'루브릭·표준 지표가 수업의 목표가 되곤 한다.'},
      {id:40, code:'실존', text:'세세한 지시보다는 여백이 있을 때 수업이 살아난다.'}
    ];

    // 상태
    let cards = JSON.parse(JSON.stringify(DEFAULT_STATEMENTS));
    let columns = []; // {score, cap, el}
    let currentPreset = '40-9';
    let selectedCardId = null; // 클릭-이동 지원

    // DOM 참조
    const poolList = document.getElementById('poolList');
    const rowEl = document.getElementById('row');
    const summaryEl = document.getElementById('summary');
    const presetSel = document.getElementById('preset');

    // 도우미
    function makeEl(tag, cls){ const e=document.createElement(tag); if(cls) e.className=cls; return e; }

    function renderColumns(){
      rowEl.innerHTML = '';
      columns = [];
      const {scores, caps} = PRESETS[currentPreset];
      scores.forEach((score, i)=>{
        const col = makeEl('div','col dropzone');
        col.dataset.score = score;
        const head = makeEl('div','col-header');
        const tag = makeEl('div','tag');
        tag.textContent = `${score>0? '+'+score : score}`;
        const cap = makeEl('div','cap');
        cap.innerHTML = `할당 <span class="capnum">${caps[i]}</span> / <span class="usednum">0</span>`;
        head.append(tag,cap);
        const bucket = makeEl('div','bucket');
        col.append(head,bucket);
        rowEl.append(col);
        columns.push({score, cap:caps[i], el:col});
      });
      attachDnD();
      refreshAll();
    }

    function getBucket(colEl){ return colEl.querySelector('.bucket'); }
    function capStatus(col){
      const used = getBucket(col.el).children.length;
      const cap = col.cap;
      const status = used===cap? 'count-ok' : (used<cap? 'count-warn' : 'count-bad');
      const usednum = col.el.querySelector('.usednum');
      usednum.textContent = used;
      usednum.className = status;
      col.el.classList.toggle('over', used>cap);
    }

    function refreshAll(){
      // 풀 렌더
      poolList.innerHTML = '';
      const inPool = cards.filter(c=> !document.querySelector(`.card[data-id="${c.id}"]`));
      // (초기에는 모두 풀에 그려짐)
      // 여기선 아무것도 하지 않음 — 카드 생성은 ensureCards()

      // 칼럼 카운트 업데이트
      columns.forEach(capStatus);
      updateSummary();
    }

    function createCardEl(card){
      const el = makeEl('div','card');
      el.draggable = true;
      el.dataset.id = card.id;
      el.innerHTML = `<div class="small" style="opacity:.7">#${card.id} · ${card.code}</div>${card.text}`;
      el.addEventListener('dragstart', (e)=>{
        el.classList.add('dragging');
        e.dataTransfer.setData('text/plain', String(card.id));
      });
      el.addEventListener('dragend', ()=> el.classList.remove('dragging'));
      el.addEventListener('click', ()=>{
        // 클릭-이동
        if(selectedCardId===card.id){ selectedCardId=null; el.style.outline=''; return; }
        document.querySelectorAll('.card').forEach(c=> c.style.outline='');
        selectedCardId = card.id;
        el.style.outline=`2px solid ${getComputedStyle(document.documentElement).getPropertyValue('--accent')}`;
      });
      return el;
    }

    function ensureCards(){
      // 풀에 없는 카드를 모두 풀에 추가
      const existingIds = new Set([...document.querySelectorAll('.card')].map(e=> +e.dataset.id));
      cards.forEach(c=>{
        if(!existingIds.has(c.id)) poolList.appendChild(createCardEl(c));
      });
    }

    function attachDnD(){
      const zones = document.querySelectorAll('.dropzone');
      zones.forEach(z=>{
        z.addEventListener('dragover', (e)=>{
          e.preventDefault();
          z.classList.add('over');
        });
        z.addEventListener('dragleave', ()=> z.classList.remove('over'));
        z.addEventListener('drop', (e)=>{
          e.preventDefault();
          z.classList.remove('over');
          const id = +e.dataTransfer.getData('text/plain');
          moveCardTo(id, z);
        });
        // 클릭-이동 지원
        z.addEventListener('click', (e)=>{
          if(selectedCardId!=null){
            moveCardTo(selectedCardId, z);
            selectedCardId=null;
            document.querySelectorAll('.card').forEach(c=> c.style.outline='');
          }
        });
      });
    }

    function moveCardTo(id, zone){
      const cardEl = document.querySelector(`.card[data-id="${id}"]`);
      if(!cardEl) return;
      const targetBucket = zone.id==='pool' ? poolList : getBucket(zone);
      // 용량 체크
      if(zone.id!=='pool'){
        const col = columns.find(c=> String(c.score)===zone.dataset.score);
        const used = getBucket(zone).children.length;
        if(used >= col.cap){
          // 가득 찼으면 막기
          zone.classList.add('over');
          setTimeout(()=> zone.classList.remove('over'), 300);
          return;
        }
      }
      targetBucket.appendChild(cardEl);
      columns.forEach(capStatus);
      updateSummary();
    }

    function updateSummary(){
      const lines = [];
      // 각 칼럼 목록 요약
      columns.forEach(c=>{
        const ids = [...getBucket(c.el).children].map(e=> e.dataset.id);
        lines.push(`${c.score>0? '+'+c.score:c.score}: ${ids.join(', ')||'-'}`);
      });
      const poolIds = [...poolList.children].map(e=> e.dataset.id);
      lines.push(`미배치: ${poolIds.join(', ')||'-'}`);
      summaryEl.textContent = lines.join('\n');
    }

    // 가져오기/내보내기
    document.getElementById('exportCSV').addEventListener('click', ()=>{
      // score, id, code, text
      const rows = [['score','id','code','text']];
      columns.forEach(c=>{
        [...getBucket(c.el).children].forEach(cardEl=>{
          const id = +cardEl.dataset.id;
          const card = cards.find(k=> k.id===id);
          rows.push([c.score, id, card.code, card.text]);
        });
      });
      // pool (미배치는 score = '')
      [...poolList.children].forEach(cardEl=>{
        const id = +cardEl.dataset.id;
        const card = cards.find(k=> k.id===id);
        rows.push(['', id, card.code, card.text]);
      });
      const csv = rows.map(r=> r.map(v=> '"'+String(v).replaceAll('"','""')+'"').join(',')).join('\n');
      downloadText(csv, 'qsort_result.csv', 'text/csv');
    });

    document.getElementById('exportJSON').addEventListener('click', ()=>{
      const result = { preset: currentPreset, columns: [] , pool: [] };
      columns.forEach(c=>{
        const ids = [...getBucket(c.el).children].map(e=> +e.dataset.id);
        result.columns.push({score:c.score, ids});
      });
      result.pool = [...poolList.children].map(e=> +e.dataset.id);
      downloadText(JSON.stringify(result,null,2), 'qsort_result.json', 'application/json');
    });

    function downloadText(text, filename, mime){
      const blob = new Blob([text], {type:mime});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      a.click();
      URL.revokeObjectURL(a.href);
    }

    document.getElementById('importFile').addEventListener('change', async (e)=>{
      const file = e.target.files[0]; if(!file) return;
      const text = await file.text();
      try{
        if(file.name.endsWith('.json')){
          const data = JSON.parse(text);
          if(Array.isArray(data)){
            // [{id,code,text}]
            cards = data.map(x=> ({id:+x.id, code:x.code||'', text:x.text||''}));
            resetAll();
          } else if(data.columns){
            // 결과 복원
            resetAll();
            // 카드가 이미 DEFAULT 기준으로 존재한다고 가정
            data.columns.forEach(col=>{
              const zone = [...document.querySelectorAll('.dropzone')].find(z=> z.dataset.score==String(col.score));
              col.ids.forEach(id=> moveCardTo(id, zone));
            });
          }
        } else {
          // CSV: id,code,text (헤더 허용)
          const rows = text.split(/\r?\n/).filter(Boolean).map(r=> r.split(',').map(s=> s.replace(/^\"|\"$/g,'').replaceAll('""','"')));
          const header = rows[0].map(s=> s.trim().toLowerCase());
          let start = 0;
          if(header.includes('id') && header.includes('text')) start = 1;
          cards = rows.slice(start).map((r,i)=> ({
            id: +r[0] || (i+1),
            code: r[1] || '',
            text: r.slice(2).join(',') || ''
          }));
          resetAll();
        }
      }catch(err){
        alert('가져오기 실패: '+err.message);
      }
      e.target.value='';
    });

    function resetAll(){
      // 풀/컬럼 비우고 카드 다시 생성
      document.querySelectorAll('.bucket').forEach(b=> b.innerHTML='');
      // 풀에 전부 채우기
      cards.forEach(c=> poolList.appendChild(createCardEl(c)));
      columns.forEach(capStatus);
      updateSummary();
    }

    document.getElementById('reset').addEventListener('click', ()=> resetAll());
    presetSel.addEventListener('change', (e)=>{ currentPreset = e.target.value; renderColumns(); ensureCards(); });

    // 초기 렌더
    renderColumns();
    // 카드 생성
    ensureCards();
  </script>
</body>
</html>
