<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="utf-8"/>
    <meta content="width=device-width, initial-scale=1" name="viewport"/>
    <title>교사의 교육과정 해석을 통한 의미 구성의 코드 유형 탐구(Q방법론)</title>
    <style>
        /* 기존 CSS 코드 */
        :root{ --bg:#0f172a; --panel:#111827; --card:#1f2937; --muted:#94a3b8; --text:#e5e7eb; --accent:#6366f1; --ok:#22c5e; --warn:#f59e0b; --bad:#ef4444; }
        *{box-sizing:border-box}
        body{margin:0;background:var(--bg);color:var(--text);font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Apple SD Gothic Neo,Noto Sans KR,sans-serif}
        header{position:sticky;top:0;z-index:50;background:linear-gradient(180deg,rgba(15,23,42,.95),rgba(15,23,42,.6));backdrop-filter:blur(8px);border-bottom:1px solid #1f2937}
        .wrap{max-width:1200px;margin:0 auto;padding:16px}
        h1{font-size:20px;margin:0 0 6px}
        .sub{color:var(--muted);font-size:13px}
        .hidden{display:none}
        button,select,input,textarea{background:var(--card);color:var(--text);border:1px solid #334155;border-radius:10px;padding:10px 12px;font-size:14px}
        button{font-weight:700;cursor:pointer}
        button[disabled]{opacity:.6;cursor:not-allowed}
        button:hover{border-color:var(--accent)}
        input,textarea,select{width:100%}
        .grid{display:grid;grid-template-columns:320px 1fr;gap:16px;margin-top:12px}
        #pool,.col{background:var(--panel);border:1px solid #2b3647;border-radius:12px}
        #pool{padding:12px;min-height:220px}
        .toolbar{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0}
        .note{font-size:13px;color:var(--muted)}
        .cols{display:grid;gap:10px}
        .row{display:grid;gap:10px;grid-template-columns:repeat(9,1fr)}
        .col{min-height: 80px;padding:8px;display:flex;flex-direction:column}
        .col-header{display:flex;align-items:center;justify-content:space-between;padding:4px 6px;margin-bottom:6px;border-bottom:1px dashed #334155}
        .tag{font-size:12px;color:var(--muted)}
        .cap{font-size:12px}
        .bucket{display:flex;flex-direction:column;gap:6px}
        .card{font-size: 13px; background:var(--card);border:1px solid #334155;border-radius:12px;padding: 8px 10px;cursor:grab;margin-bottom:6px}
        .card.dragging{opacity:.6}
        .col.over{outline:2px dashed var(--accent);outline-offset:-4px}
        .count-ok{color:var(--ok)}
        .count-warn{color:var(--warn)}
        .count-bad{color:var(--bad)}
        .small{font-size:12px}
        .chips{display:flex;gap:6px;flex-wrap:wrap;margin-top:6px}
        .chip{background:#0b1222;border:1px solid #2b3647;border-radius:999px;padding:2px 8px;font-size:12px}
        .page{max-width:900px;margin:20px auto;padding:16px;background:var(--panel);border:1px solid #2b3647;border-radius:14px}
        .row2{display:grid;grid-template-columns:1fr 1fr;gap:12px}
        label{font-size:13px;color:var(--muted);display:block;margin:10px 0 6px}
        /* 체크박스 라벨 정렬/간격 */
        .checkbox-group{display:flex;flex-direction:column;gap:8px;margin-top:8px}
        .checkbox-item{display:flex;align-items:center;gap:8px}
        .checkbox-item input[type="checkbox"]{width:16px;height:16px;margin:0;vertical-align:middle}
      
        /* Modal styles */
        .modal.hidden { display: none; }
        .modal { position: fixed; inset: 0; z-index: 1000; }
        .modal__overlay { position:absolute; inset:0; background: rgba(0,0,0,.5); backdrop-filter: blur(2px); }
        .modal__content { position:relative; max-width: 720px; margin: 8vh auto; background: var(--panel); border:1px solid #2b3647; border-radius: 12px; padding: 16px; }

        #poolContainer {
            border-right: 1px dashed #ccc; /* 카드풀과 분포도 사이의 구분선 */
        }
        #poolList {
            display: block;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 8px;
            width: 100%;
            box-sizing: border-box;
            scrollbar-gutter: stable;  /* 스크롤바 공간 확보 */
        }
        #poolList .card {
            display: block;
            width: 100%;               /* 카드 폭 그대로 */
            margin-bottom: 8px;
        }

        #submitBtn {
          font-size: 18px;
          font-weight: bold;
          padding: 14px 22px;
          background: var(--accent);
          color: white;
          border-radius: 12px;
          border: none;
        }
        #submitBtn:hover {
          background: #4338ca;
        }
        /* === Responsive width tuning (columns >= card width) === */
        :root { --card-w: 240px; }

        @media (max-width: 1600px) { :root { --card-w: 220px; } }
        @media (max-width: 1440px) { :root { --card-w: 200px; } }
        @media (max-width: 1280px) { :root { --card-w: 180px; } }

        /* Use almost full viewport width */
        .page { max-width: 98vw !important; }

        /* Shrink left sidebar when space tight, give all remaining space to board */
        .grid { grid-template-columns: clamp(200px, 18vw, 280px) 1fr !important; }

        /* Each column at least as wide as a card */
        .row { grid-template-columns: repeat(9, minmax(var(--card-w), 1fr)) !important; }

        /* Cards fill column width; in the pool they use card width */
        #pool .card { width: var(--card-w); }
        .col .bucket .card { width: 100%; }

        /* Slightly smaller gutters to win horizontal space */
        .row { gap: 8px !important; }
        .cols { gap: 8px !important; }

        /* 추가된 상태 메시지 스타일 */
        .status-message {
            margin-top: 50px;
            padding: 20px;
            text-align: center;
            font-size: 1.5em;
            font-weight: bold;
            color: var(--text);
            background: var(--panel);
            border-radius: 12px;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
            border: 1px solid var(--accent);
        }
        .status-message.error {
            color: var(--bad);
            border-color: var(--bad);
        }
        .status-message.info {
            color: var(--accent);
            border-color: var(--accent);
        }
        .status-message.success {
            color: var(--ok);
            border-color: var(--ok);
        }
    </style>
</head>
<body>
    <header>
        <div class="wrap">
            <h1>교사의 교육과정 해석을 통한 의미 구성의 코드 유형 탐구 (Q방법론)</h1>
            <div class="sub">본 설문은 교사의 교육과정 해석 유형을 탐색하는 연구입니다.</div>
        </div>
    </header>

    <!-- 토큰 상태 메시지 표시 영역 -->
    <div id="status-message" class="status-message info">
        설문을 불러오는 중입니다. 잠시만 기다려 주세요...
    </div>

    <!-- 실제 설문 콘텐츠 (토큰 유효성 검증 후 표시) -->
    <div id="survey-main-content" class="hidden">
        <form id="q-sort-form">
            <!-- 조경철2577님께서 요청하신 Q-진술문 분류 부분만 남깁니다. -->
            <!-- 이전에 제가 임의로 추가했던 인구 통계 정보는 제거되었습니다. -->

            <div class="page">
                <h2>Q-진술문 분류 (카드 분류)</h2>
                <p class="note">아래 35개 진술문을 가장 동의하는 것부터 동의하지 않는 것까지 [-4] 에서 [+4] 스케일에 맞춰 분포표에 분류해주세요.</p>

                <div class="grid">
                    <div id="poolContainer">
                        <h3><span id="poolCount" class="count-ok">0</span>개 남음</h3>
                        <p class="note">여기에 분류할 카드들이 있습니다.</p>
                        <div id="poolList">
                            <!-- Q-Cards will be loaded here -->
                        </div>
                    </div>

                    <div id="sortGrid">
                        <h3>분포표</h3>
                        <div class="toolbar">
                            <div class="chips">
                                <span class="chip">매우 부정 [-4]</span>
                                <span class="chip">다소 부정 [-2]</span>
                                <span class="chip">중립 [0]</span>
                                <span class="chip">다소 긍정 [+2]</span>
                                <span class="chip">매우 긍정 [+4]</span>
                            </div>
                        </div>

                        <div class="cols">
                            <div class="row">
                                <div class="col" data-score="-4"><div class="col-header small"><span class="tag">-4</span> <span class="cap">2개</span></div><div class="bucket"></div></div>
                                <div class="col" data-score="-3"><div class="col-header small"><span class="tag">-3</span> <span class="cap">3개</span></div><div class="bucket"></div></div>
                                <div class="col" data-score="-2"><div class="col-header small"><span class="tag">-2</span> <span class="cap">5개</span></div><div class="bucket"></div></div>
                                <div class="col" data-score="-1"><div class="col-header small"><span class="tag">-1</span> <span class="cap">6개</span></div><div class="bucket"></div></div>
                                <div class="col" data-score="0"><div class="col-header small"><span class="tag">0</span> <span class="cap">7개</span></div><div class="bucket"></div></div>
                                <div class="col" data-score="1"><div class="col-header small"><span class="tag">+1</span> <span class="cap">6개</span></div><div class="bucket"></div></div>
                                <div class="col" data-score="2"><div class="col-header small"><span class="tag">+2</span> <span class="cap">5개</span></div><div class="bucket"></div></div>
                                <div class="col" data-score="3"><div class="col-header small"><span class="tag">+3</span> <span class="cap">3개</span></div><div class="bucket"></div></div>
                                <div class="col" data-score="4"><div class="col-header small"><span class="tag">+4</span> <span class="cap">2개</span></div><div class="bucket"></div></div>
                            </div>
                        </div>
                        <p class="note">각 칸에 지정된 개수만큼 카드를 분류해주세요. 숫자는 자동으로 업데이트됩니다.</p>
                        <div style="text-align:center; margin-top:20px;">
                            <button type="submit" id="submitBtn">설문 제출 완료</button>
                        </div>
                    </div>
                </div>
            </div>
        </form>
    </div>

    <!-- JavaScript 로직 -->
    <script>
        // 🚨 토큰 관리 (확인 및 사용 처리) Apps Script 웹 앱 URL
        const TOKEN_WEB_APP_URL = "https://script.google.com/macros/s/AKfycbzhxw3kVbBBEJhPGAHXBxoL4S7vZKbqwCK5I5PeaeYEDLIO0u1l2VYwTpAMi-ywRem6og/exec";
        // 🚨 Q방법론 응답 결과가 저장되는 Apps Script 웹 앱 URL (doPost 필요)
        const Q_SURVEY_DATA_SUBMIT_URL = "https://script.google.com/macros/s/AKfycbxr3fORzxqC94mS_KAWSeL_NFwzIctrus9ntJSfHjofSUMNqTmH7Pb7fZfqeLoQMRNwdA/exec";

        const statusMessageDiv = document.getElementById('status-message');
        const surveyMainContent = document.getElementById('survey-main-content');
        const qSortForm = document.getElementById('q-sort-form');
        let currentToken = ''; // 현재 토큰 저장

        // URL 파라미터에서 특정 값을 가져오는 함수
        function getUrlParameter(name) {
            name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
            const regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
            const results = regex.exec(location.search);
            return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
        }

        // Apps Script 웹 앱으로 요청을 보내고 응답을 받는 함수
        async function callAppsScript(url, action, token) {
            const fullUrl = `${url}?action=${action}&token=${encodeURIComponent(token)}`;
            try {
                const response = await fetch(fullUrl);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                return data;
            } catch (error) {
                console.error(`Apps Script (${action}) 호출 중 오류 발생:`, error);
                return { ok: false, status: "error", message: "서버 통신 오류" };
            }
        }

        // 페이지 로드 시 토큰 검증 로직 실행
        document.addEventListener('DOMContentLoaded', async () => {
            currentToken = getUrlParameter('token');

            if (!currentToken) {
                statusMessageDiv.className = 'status-message error';
                statusMessageDiv.innerHTML = '유효한 설문 토큰이 URL에 포함되어 있지 않습니다. 다시 확인해 주세요.';
                return;
            }

            // 토큰 유효성 검증
            statusMessageDiv.className = 'status-message info';
            statusMessageDiv.innerHTML = '토큰을 확인 중입니다...';
            const checkResult = await callAppsScript(TOKEN_WEB_APP_URL, 'checkToken', currentToken);

            if (!checkResult.ok) {
                statusMessageDiv.className = 'status-message error';
                statusMessageDiv.innerHTML = `토큰 확인 중 오류가 발생했습니다: ${checkResult.message || '알 수 없는 오류'}`;
            } else {
                if (checkResult.status === 'valid') {
                    // 유효한 토큰, 설문 표시
                    statusMessageDiv.classList.add('hidden'); // 상태 메시지 숨기기
                    surveyMainContent.classList.remove('hidden'); // 설문 내용 보이기
                    initializeQSorting(); // Q-Sorting 초기화 함수 호출
                } else if (checkResult.status === 'used') {
                    // 이미 사용된 토큰
                    statusMessageDiv.className = 'status-message info';
                    statusMessageDiv.innerHTML = '이미 이 토큰으로 설문에 참여하셨습니다. 중복 참여는 불가능합니다.';
                } else if (checkResult.status === 'invalid') {
                    // 유효하지 않거나 존재하지 않는 토큰
                    statusMessageDiv.className = 'status-message error';
                    statusMessageDiv.innerHTML = '유효하지 않거나 존재하지 않는 설문 토큰입니다. 올바른 주소로 접속해 주세요.';
                } else {
                    statusMessageDiv.className = 'status-message error';
                    statusMessageDiv.innerHTML = '알 수 없는 토큰 상태입니다. 관리자에게 문의해 주세요.';
                }
            }
        });

        // 설문 제출 시 토큰 사용 처리 (markUsed)
        qSortForm.addEventListener('submit', async (event) => {
            event.preventDefault(); // 폼의 기본 제출 동작 방지

            // Q 분류 데이터를 수집
            const qSortingResults = collectQSortingResults();
            if (!qSortingResults) return; // Q 분류 결과 수집 실패 또는 유효성 검사 실패

            // 인구 통계 정보가 없으므로 generalData는 빈 객체로 전송
            const generalData = {};
            
            console.log("Q 분류 설문 데이터 제출 시도:", generalData, qSortingResults);
            
            statusMessageDiv.classList.remove('hidden'); // 상태 메시지 영역 다시 보이게
            statusMessageDiv.className = 'status-message info';
            statusMessageDiv.innerHTML = '설문 내용을 제출하고 있습니다...';
            surveyMainContent.classList.add('hidden'); // 설문 내용 숨기기

            try {
                // 1. Q방법론 응답 결과 데이터를 Q_SURVEY_DATA_SUBMIT_URL로 POST 전송
                const response = await fetch(Q_SURVEY_DATA_SUBMIT_URL, {
                    method: 'POST',
                    body: JSON.stringify({ token: currentToken, general: generalData, qSort: qSortingResults }),
                    headers: { 'Content-Type': 'text/plain' } // Apps Script는 'application/json' 대신 'text/plain'을 선호
                });
                const responseData = await response.json();

                if (!responseData.ok) {
                    throw new Error(responseData.message || '설문 데이터 저장에 실패했습니다.');
                }

                // 2. 설문 데이터 저장 성공 후, 토큰 사용 완료 처리 (TOKEN_WEB_APP_URL 사용)
                const markUsedResult = await callAppsScript(TOKEN_WEB_APP_URL, 'markUsed', currentToken);

                if (markUsedResult.ok) {
                    statusMessageDiv.className = 'status-message success';
                    statusMessageDiv.innerHTML = '설문 응답이 성공적으로 제출되었고, 토큰이 사용 완료 처리되었습니다. 소중한 의견 감사드립니다!';
                } else {
                    statusMessageDiv.className = 'status-message error';
                    statusMessageDiv.innerHTML = `설문 데이터는 저장되었지만, 토큰 사용 처리 중 오류가 발생했습니다: ${markUsedResult.message || '알 수 없는 오류'}. 관리자에게 문의해 주세요.`;
                    console.error("markUsed 실패:", markUsedResult);
                }
            } catch (error) {
                console.error("설문 데이터 전송 또는 토큰 처리 중 오류 발생:", error);
                statusMessageDiv.className = 'status-message error';
                statusMessageDiv.innerHTML = `설문 제출 중 오류가 발생했습니다: ${error.message}. 관리자에게 문의해 주세요.`;
            }
        });
        
        // 인구 통계 정보가 없으므로 validateGeneralForm 함수는 필요 없으나,
        // 혹시 나중에 추가할 경우를 대비하여 주석 처리하거나 제거 가능
        /*
        function validateGeneralForm(generalData) {
            // 현재 일반 폼 데이터가 없으므로 항상 true 반환
            return true;
        }
        */

        // --- Q-Sorting 관련 JavaScript 함수 (initializeQSorting 등) ---
        function initializeQSorting() {
            console.log("Q-Sorting 기능 초기화 중...");
            
            const qStatements = [
                { id: 'q1', text: '교육과정은 학생들의 흥미를 최우선으로 반영해야 한다.' },
                { id: 'q2', text: '교육과정은 사회적 요구와 미래 변화에 빠르게 대응해야 한다.' },
                { id: 'q3', text: '교사는 교육과정을 자신의 교육 철학에 따라 자유롭게 재구성할 권리가 있다.' },
                { id: 'q4', text: '교육과정은 국가의 기본적인 교육 목표와 가치를 명확히 제시해야 한다.' },
                { id: 'q5', text: '학생들은 교육과정 개발과 운영 과정에 적극적으로 참여해야 한다.' },
                { id: 'q6', text: '교육과정은 교사의 전문성을 발휘할 수 있는 여지를 충분히 제공해야 한다.' },
                { id: 'q7', text: '교육과정은 평가의 공정성과 객관성을 확보하는 데 중점을 두어야 한다.' },
                { id: 'q8', text: '교육과정은 다양한 문화적 배경을 가진 학생들을 포용해야 한다.' },
                { id: 'q9', text: '기술 발전은 교육과정의 내용을 끊임없이 변화시켜야 한다.' },
                { id: 'q10', text: '교육과정은 학생들에게 비판적 사고 능력을 함양시키는 데 주력해야 한다.' },
                { id: 'q11', text: '교사의 역할은 교육과정에 명시된 내용을 정확하게 전달하는 것이다.' },
                { id: 'q12', text: '교육과정은 창의성과 혁신을 위한 탐구 활동을 강조해야 한다.' },
                { id: 'q13', text: '교육과정은 특정 과목 지식보다 전인적 성장을 위한 경험을 제공해야 한다.' },
                { id: 'q14', text: '교육과정은 지역 사회의 특성과 요구를 반영하여 유연하게 운영되어야 한다.' },
                { id: 'q15', text: '교육과정 개발 시 학생들의 의견 수렴 과정이 필수적이다.' },
                { id: 'q16', text: '교사는 교육과정 재구성을 위해 지속적인 연수와 연구가 필요하다.' },
                { id: 'q17', text: '교육과정은 결과 중심 평가보다 과정 중심 평가를 우선해야 한다.' },
                { id: 'q18', text: '미래 사회를 대비하여 교육과정에 디지털 리터러시 교육을 강화해야 한다.' },
                { id: 'q19', text: '교육과정은 학습 내용의 양보다는 질적 깊이를 추구해야 한다.' },
                { id: 'q20', text: '교육과정은 학생들의 진로 탐색과 설계를 적극적으로 지원해야 한다.' },
                { id: 'q21', text: '교육과정은 학교 간, 지역 간 학력 격차 해소에 기여해야 한다.' },
                { id: 'q22', text: '교사는 교육과정 실행 시 발생하는 문제 상황을 적극적으로 해결해야 한다.' },
                { id: 'q23', text: '교육과정은 학생들에게 자기 주도 학습 능력을 길러주는 방향으로 구성되어야 한다.' },
                { id: 'q24', text: '교육과정은 다양한 교과를 통합하여 유기적으로 구성해야 한다.' },
                { id: 'q25', text: '교육과정은 학생들에게 사회적 책임감과 시민 의식을 함양시켜야 한다.' },
                { id: 'q26', text: '교사는 교육과정 운영의 자율성을 존중받아야 한다.' },
                { id: 'q27', text: '교육과정은 급변하는 시대에 적응할 수 있는 유연성을 갖춰야 한다.' },
                { id: 'q28', text: '교육과정은 인성 교육을 강화하고 가치관 형성에 도움을 주어야 한다.' },
                { id: 'q29', text: '교육과정은 학생들의 건강한 신체 발달을 위한 내용을 포함해야 한다.' },
                { id: 'q30', text: '교사는 교육과정 평가 결과에 따라 교육 방법을 개선해야 한다.' },
                { id: 'q31', text: '교육과정은 국가 교육 목표 달성을 위한 구체적인 지침을 제공해야 한다.' },
                { id: 'q32', text: '교육과정은 학생들의 잠재력을 최대한 발휘할 수 있도록 지원해야 한다.' },
                { id: 'q33', text: '교육과정은 교과 지식 전달을 넘어 실생활 문제 해결 능력을 강조해야 한다.' },
                { id: 'q34', text: '교사는 교육과정 관련 전문가들과 지속적으로 협력해야 한다.' },
                { id: 'q35', text: '교육과정은 학생들이 비판적 시각으로 세상을 이해하도록 돕는 역할을 해야 한다.' }
            ];

            const poolList = document.getElementById('poolList');
            poolList.innerHTML = ''; // 기존 내용 지우기
            qStatements.forEach(statement => {
                const card = document.createElement('div');
                card.className = 'card';
                card.setAttribute('draggable', 'true');
                card.setAttribute('data-id', statement.id);
                card.textContent = statement.text;
                poolList.appendChild(card);
            });

            // 드래그 앤 드롭 이벤트 리스너 설정
            setupDragAndDrop();
            updateCounts(); // 카드 개수 초기화
        }

        // --- Q-Sorting 드래그 앤 드롭 및 카운트 업데이트 로직 ---
        function setupDragAndDrop() {
            const cards = document.querySelectorAll('.card');
            const buckets = document.querySelectorAll('.bucket');

            cards.forEach(card => {
                card.addEventListener('dragstart', dragStart);
            });

            buckets.forEach(bucket => {
                bucket.addEventListener('dragover', dragOver);
                bucket.addEventListener('dragleave', dragLeave);
                bucket.addEventListener('drop', drop);
            });

            // 드래그 앤 드롭 기본 동작 설정: poolList도 드롭존으로 설정
            const poolList = document.getElementById('poolList');
            poolList.addEventListener('dragover', dragOver);
            poolList.addEventListener('dragleave', dragLeave);
            poolList.addEventListener('drop', drop);


            function dragStart(e) {
                e.dataTransfer.setData('text/plain', e.target.dataset.id);
                setTimeout(() => e.target.classList.add('dragging'), 0);
            }

            function dragOver(e) {
                e.preventDefault(); // 드롭 허용
                if (e.target.classList.contains('bucket') || e.target.id === 'poolList') {
                     e.target.closest('.col')?.classList.add('over');
                     if (e.target.id === 'poolList') {
                         e.target.classList.add('over');
                     }
                }
            }

            function dragLeave(e) {
                if (e.target.closest('.col')) {
                    e.target.closest('.col').classList.remove('over');
                }
                 if (e.target.id === 'poolList') {
                     e.target.classList.remove('over');
                 }
            }

            function drop(e) {
                e.preventDefault();
                const cardId = e.dataTransfer.getData('text/plain');
                const draggedCard = document.querySelector(`.card[data-id="${cardId}"]`);
                const targetBucket = e.target.closest('.bucket');
                const targetCol = e.target.closest('.col');
                
                // 드래그 중인 카드 상태 초기화
                if (draggedCard) {
                    draggedCard.classList.remove('dragging');
                }
                document.querySelectorAll('.col.over, #poolList.over').forEach(el => el.classList.remove('over'));


                if (targetBucket && targetCol) { // 특정 점수 버킷으로 드롭
                    const score = parseInt(targetCol.dataset.score);
                    const cap = parseInt(targetCol.querySelector('.cap').getAttribute('data-initial-cap'));
                    
                    if (targetBucket.children.length < cap) {
                        targetBucket.appendChild(draggedCard);
                        updateCounts();
                    } else {
                        alert(`이 칸은 ${cap}개의 카드만 수용할 수 있습니다.`);
                    }
                } else if (e.target.id === 'poolList' || e.target.closest('#poolList')) { // 카드 풀로 드롭
                    poolList.appendChild(draggedCard);
                    updateCounts();
                } else {
                     // 유효하지 않은 드롭 위치, 카드를 원래 위치로 돌리거나 아무것도 하지 않음.
                     // 현재 구현은 드래그 시작 전 위치를 기억하지 않으므로, 이 경우 pool로 돌려보냄.
                     poolList.appendChild(draggedCard);
                     updateCounts();
                }
            }
        }
        
        // 카드 개수 업데이트 및 시각화
        function updateCounts() {
            const poolList = document.getElementById('poolList');
            const poolCountSpan = document.getElementById('poolCount');
            const totalCards = 35; // 전체 카드 개수 (Q 진술문 개수)
            
            // poolList에 남아있는 카드 수 업데이트
            poolCountSpan.textContent = totalCards - Array.from(document.querySelectorAll('.bucket .card')).length;

            if (poolCountSpan.textContent === '0') {
                poolCountSpan.className = 'count-ok';
            } else if (parseInt(poolCountSpan.textContent) < 5) {
                poolCountSpan.className = 'count-warn';
            } else {
                poolCountSpan.className = 'count-bad';
            }

            const cols = document.querySelectorAll('.col');
            let allColsFilled = true;
            cols.forEach(col => {
                const score = parseInt(col.dataset.score);
                const capElement = col.querySelector('.col-header .cap');
                // cap 값을 data-initial-cap에서 가져오도록 수정
                const cap = parseInt(capElement.getAttribute('data-initial-cap')); 
                const current = col.querySelector('.bucket').children.length;
                
                capElement.textContent = `${current} / ${cap}개`; // 현재 카운트 / 최대 개수
                if (current === cap) {
                    capElement.className = 'cap count-ok';
                } else {
                    capElement.className = 'cap count-warn'; // 덜 채워졌거나 넘친 경우
                    allColsFilled = false;
                }
            });

            // 제출 버튼 활성화/비활성화 (모든 카드가 분류되고 모든 칸이 올바르게 채워졌을 때)
            const submitBtn = document.getElementById('submitBtn');
            const isAllQCardSorted = poolCountSpan.textContent === '0' && allColsFilled;
            if (isAllQCardSorted) {
                submitBtn.removeAttribute('disabled');
            } else {
                submitBtn.setAttribute('disabled', 'true');
            }
        }

        // Q 분류 결과를 수집하여 반환하는 함수
        function collectQSortingResults() {
            const results = {};
            const cols = document.querySelectorAll('.col');
            let isValid = true; // 모든 칸이 올바르게 채워졌는지 확인

            cols.forEach(col => {
                const score = parseInt(col.dataset.score);
                const cap = parseInt(col.querySelector('.cap').getAttribute('data-initial-cap'));
                const cardsInBucket = Array.from(col.querySelector('.bucket').children);

                if (cardsInBucket.length !== cap) {
                    isValid = false; // 칸의 개수가 맞지 않음
                    return;
                }

                cardsInBucket.forEach(card => {
                    results[card.dataset.id] = score;
                });
            });

            const poolList = document.getElementById('poolList');
            if (poolList.children.length > 0) {
                isValid = false; // 카드 풀에 카드가 남아있음
            }
            
            if (!isValid) {
                alert('모든 Q 진술문을 정확한 개수에 맞춰 분류해야 설문을 제출할 수 있습니다.');
                return null;
            }
            return results;
        }

        // 최초 페이지 로드 시, .cap 요소에 data-initial-cap 속성 추가 (한번만 실행)
        document.querySelectorAll('.col-header .cap').forEach(capElement => {
            if (!capElement.hasAttribute('data-initial-cap')) {
                const initialCapText = capElement.textContent.match(/\d+/); // "2개"에서 "2" 추출
                if (initialCapText) {
                    capElement.setAttribute('data-initial-cap', parseInt(initialCapText[0]));
                }
            }
        });

    </script>
</body>
</html>
